---
layout: post
title: "关于并发控制的乐观方法"
date: 2017-05-10
category: 论文
keywords: 并发控制, OCC, 乐观并发
---

## 介绍

本论文发表于1981年。

### 数据库和事务

* 数据库是什么？
1. 数据库是对象的集合,对数据库的共享访问就是对这些对象的访问;
2. 对象分为两类: roots, 它们是一些distinguished objects; 其他对象,必须先访问roots,然后通过指向这些对象的指针来访问;
* 事务是什么？
1. 对数据库中的对象的一系列访问的集合;
2. 保证访问数据的完整性约束;

### 锁并发控制

现有加锁方法来控制并发的缺点:
1. 锁的管理负荷。 只读事务也要加锁; 死锁检测的负载;
2. no general-purpose deadlock-free locking protocols。 B-Tree索引在其他论文中有9种加锁协议;
3. 对象加锁后,等待磁盘访问的过程中,降低了访问的并发度;
4. 不得已回滚事务时,必须要到事务结束时才能释放所有锁,这也降低了访问的并发度;
5. 加锁应该是在最坏的情况下的选择,而不应该是一种常态;

## 无锁机制

**前提条件**
1. 在给定时刻,数据库中的对象要比运行中的事务所涉及的对象数目要多得多;
2. 运行中的事务同时修改数据库中的同一对象的概率要小得多;

以上 2 点主要说明事务模型的冲突是不常见的

**主要想法**
1. 读是不受限制的,主要指从一个节点读取其值或指针;但是,一个查询的结果返回认为是一个写操作,需要进行校验;
2. 写是严格受限的。事务主要由读阶段、校验阶段、写阶段(可选)这 2/3 个阶段构成。

**主要阶段**
1. 读阶段:所有的写操作发生在局部的、节点副本上,只在事务内可见;
2. 校验阶段: 用来保证数据完整性
3. 写阶段: 校验成功后才存在,主要是让修改完成的数据全局可见;

_如果事务发生失败,需要把事务进行备份,然后再次调用重新执行。_

### 读和写阶段

底层系统提供对象的管理，主要的操作有
* Create 创建一个新对象并返回其名字
* delete(n) 删除对象 n
* read(n,i) 读取对象 n 的项 i 并返回其值
* write(n,i,v) 写入对象 n 的项 i 的值 v
* copy(n) 创建对象 n 的副本并返回其名字
* exchange(n1,n2) 交换两个对象 n1 和 n2 的名字

其中 n 是对象的名字, i 是类型管理的一个参数, v 是类型的值(可能是指针,可能是数据)

```
tcreate = (
    n := create;
    create set := create set U { n } ;
    return n
)

twrite(n, i, u) = (
    if n E create set
        then write(n, i, u)
    else if n E write set
        then write(copies[n], i, u)
    else (
        m := copy(n);
        copies[n] := m;
        write set := write set U {n};
        write (copies[n], i, u)
    )
)

tread(n, i) = (
    read set := read set U {n} ;
    if n E write set then
        return read (copies[ n], i)
    else
        return read (n, i)
)

tdelete (n) = (
    delete set := delete set U { n }
)
```

1. 对于每一个事务，它维护着自己需要访问的对象的集合。一开始，tbegin调用会初始化该集合为空。
2. 用户写的事务执行，就是上面所提及的读阶段； 
3. 用户写的tend才会触发上面所提及的校验阶段和写阶段；
4. copies是对象名字映射的向量。
5. 读阶段并不会发生全局写。对对象的第一次写，会复制一个副本，后面所有的写将会对这个对象副本进行。副本在读阶段过程中对其他事务是不可见的。

另外，我们约定：（1）所有的节点都是通过root节点的指针来访问的； 而所有事务都知道root节点的全局名字。那么，root节点的副本是无法访问的，因为它不在全局名字集合之内。（2）root节点是不会创建和删除的，节点删除后不会留下dangling pointer，创建的节点通过新建立的指针变得可访问；

事务完成之后，就会使用tend来调用校验过程。只有校验成功之后，才会进入到写阶段：
```
for n E write set do exchange (n, copies[n]).
```

写阶段完成之后，事务创建的所有节点将全局可见，事务删除掉的节点将全局不可再见。事务无论成功还是失败完成之后，将会进行一定的清理工作：
```
(for n E delete set do delete(n);
 for n E write  set do delete(copies[n])).
```

### 校验阶段

假定T<SUB>1</SUB>,T<SUB>2</SUB>,...,T<SUB>n</SUB>是并发执行的。这些事务操作的共享数据结构是d，而D是所有d的完整集合，那么事务T<SUB>i</SUB>就是这样的一个函数： 

<center>T<SUB>i</SUB>: D &rarr; D</center>

假定初始化的数据结构是d<SUB>init</SUB>，而最终的数据结构是d<SUB>final</SUB>。那么事务过程就可以看成是将一个并发事务的排列的函数组合应用于数据结构的结果，即：

![](/assets/2017/OCC_xact_00.png)

上面这个公式可以使用归纳法证明是成立的，只要每一步满足数据完整性，那么整个操作序列就可以保证数据的完整性。那么，关键的问题就是找到这样的一个事务排列。

这个排列中的两个事务需要满足下面的三个要求之一；其中，当时间t(i) < t(j) 成立时，事务T<SUB>i</SUB>一定比事务T<SUB>j</SUB>开始的早。

### 串行校验

### 并行校验


